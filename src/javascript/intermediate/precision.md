# js 浮点数精度问题

## 0.1 + 0.2 === 0.3 ？

先看结果

```js
0.1 + 0.2 === 0.3; // false
```

## 为什么 ？

在 `Javascript` 中，只有一种数据类型 `number`，它遵循 `IEE754` 标准来实现的，通过 `64bit` 固定长度来表示一个数字（标准的双精度浮点数）。

在计算 `0.1+0.2` 时，计算机无法直接计算十进制数字，而且先根据 `IEE754` 规范转变成对应的二进制，再进行对接运算

但这 `0.1` 和 `0.2` 这两个数的二进制都是死循环

```
0.1 -> 0.0001100110011001... (无限循环)
0.2 -> 0.0011001100110011... (无限循环)
```

由于 `IEE754` 位数的限制，需要将多余的位去掉再进行运算，得到

```
0.0100110011001100110011001100110011001100110011001100
```

再转成十进制

```
0.30000000000000004
```

因为精度损失，导致了计算出现了偏差问题。

## `toFixed` 处理小数精度缺失的问题

先看执行结果

```
(1.35).toFixed('1') // '1.4'
(0.35).toFixed('1') // 0.3
```

这其实也是同理，可以利用 `toPrecision` 来查询数值存的具体数值

```
(1.35).toPrecision(20) // '1.3500000000000000888'
(0.35).toPrecision(20) // '0.34999999999999997780'
```

此时保留一位小数之后，会发现

```
1.35 => 1.3500000000000000888 => 1.4
0.35 => 0.34999999999999997780 => 0.3
```

由此引发的计算问题。

## 处理精度问题相关的库

- [big.js](https://mikemcl.github.io/big.js/)
- [decimal.js](https://mikemcl.github.io/decimal.js/)
